<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitHub Contributions 3D Interactive - Enhanced</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; /* Slightly lighter dark */ }
        #container { width: 100vw; height: 100vh; display: block; }
        #tooltip {
            position: absolute;
            display: none;
            background-color: rgba(245, 245, 245, 0.95); /* Slightly off-white */
            border: 1px solid #aaa;
            padding: 10px;
            border-radius: 5px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; /* Modern font */
            font-size: 13px;
            color: #222;
            pointer-events: none;
            z-index: 100;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1); /* Subtle shadow */
        }
    </style>
</head>
<body>
    <div id="tooltip"></div>
    <div id="container"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="garden.js"></script> <!-- Load contributions data -->
    <script>
        // --- Constants ---
        const CUBE_SIZE = 1.0;
        const CUBE_SPACING = 0.3;
        const DAYS_IN_WEEK = 7;
        const WEEKS_IN_YEAR = 53; // Standard GitHub contribution graph width

        const HIGHLIGHT_COLOR = 0xffdc73; // Softer yellow for highlighting
        // const SCENE_BACKGROUND_COLOR = 0x282c34; // Darker, slightly bluish background - REMOVED for dynamic sky
        // const FOG_COLOR = SCENE_BACKGROUND_COLOR; - REMOVED for dynamic sky
        const FOG_NEAR_FACTOR = 2.5; // Fog starts further out based on grid size
        const FOG_FAR_FACTOR = 4.5;  // Fog ends further out

        // --- Pre-calculate Grid Dimensions (used in lighting setup) ---
        const GRID_WIDTH = WEEKS_IN_YEAR * (CUBE_SIZE + CUBE_SPACING);
        const GRID_DEPTH = DAYS_IN_WEEK * (CUBE_SIZE + CUBE_SPACING);

        // --- Sky Cycle Variables with Lighting --- REMOVED
        // --- Tulip Colors --- REMOVED

        // --- Minecraft Model Colors ---
        const mc_colors = {
            brown_dark: new THREE.Color(0x5C4033), // Dark Brown (Dirt/Soil)
            brown_light: new THREE.Color(0x8B4513), // Saddle Brown (Soil)
            green_dark: new THREE.Color(0x006400),  // Dark Green (Grass)
            white: new THREE.Color(0xFFFFFF),
            starbucks_green: new THREE.Color(0x00704A),
            starbucks_door_brown: new THREE.Color(0x3D2B1F),
            window_blue: new THREE.Color(0xADD8E6), // Light Blue
            mcd_red: new THREE.Color(0xFF0000),
            mcd_yellow: new THREE.Color(0xFFFF00),
            mcd_door_grey: new THREE.Color(0x696969), // Dark Grey
            lotte_light_grey: new THREE.Color(0xD3D3D3),
            lotte_medium_grey: new THREE.Color(0xA9A9A9), // Changed from 0x808080 for better distinction
            lotte_dark_blue_window: new THREE.Color(0x00008B),
            lotte_white: new THREE.Color(0xF0F0F0), // Slightly off-white for Lotte
            road_grey: new THREE.Color(0xC0C0C0) // Silver, as a light grey for road
        };


        // --- Global Three.js Variables ---
        let scene, camera, renderer, controls;
        let hemisphereLight, ambientLight, directionalLight; // Made global for updating in animate()
        let raycaster, mouse;
        let contributionCubesGroup;
        let intersectedCube = null;
        let tooltipElement;

        // --- Helper Functions ---
        // Moved createBlock here to make it globally accessible
        function createBlock(color, x, y, z) {
            const geometry = new THREE.BoxGeometry(CUBE_SIZE, CUBE_SIZE, CUBE_SIZE);
            const material = new THREE.MeshStandardMaterial({ color: color, roughness: 0.65, metalness: 0.15 });
            const block = new THREE.Mesh(geometry, material);
            block.position.set(x * CUBE_SIZE, y * CUBE_SIZE + CUBE_SIZE / 2, z * CUBE_SIZE); // Center origin of block at its base
           // block.castShadow = true;
          //  block.receiveShadow = true;
            return block;
        }

        function mapCountToColor(count) {
            if (count === 0) return 0x383838; // Darker grey for no contributions
            if (count >= 1 && count <= 2) return 0x0e4429;
            if (count >= 3 && count <= 5) return 0x006d32;
            if (count >= 6 && count <= 9) return 0x26a641;
            return 0x39d353; // GitHub's brightest green
        }
        
        function mapCountToHeight(count) {
            if (count === 0) return 0.1; // Minimal height for zero contributions
            // Logarithmic scale, slightly adjusted for more visual impact
            const height = 0.3 + Math.log1p(count) * 1.2; 
            return Math.min(height, 20); // Increased max height cap
        }

        // --- Initialization ---
        function init() {
            tooltipElement = document.getElementById('tooltip');
            
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky Blue

            // Fog
            scene.fog = new THREE.Fog(0xD0E0F0, GRID_WIDTH * 1.5, GRID_WIDTH * 4.0); // Light blue/white fog

            contributionCubesGroup = new THREE.Group();
            scene.add(contributionCubesGroup);

            // --- Minecraft Clouds ---
            const cloudGroup = new THREE.Group();
            const cloudMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
            
            function createCloud(blocksData, x, y, z) {
                const singleCloud = new THREE.Group();
                blocksData.forEach(data => {
                    const cloudBlockGeo = new THREE.BoxGeometry(data.size * CUBE_SIZE, data.size * CUBE_SIZE, data.size * CUBE_SIZE);
                    const cloudBlock = new THREE.Mesh(cloudBlockGeo, cloudMaterial);
                    cloudBlock.position.set(data.x * CUBE_SIZE, data.y * CUBE_SIZE, data.z * CUBE_SIZE);
                    cloudBlock.castShadow = false;
                    cloudBlock.receiveShadow = false; // Clouds typically don't receive shadows either
                    singleCloud.add(cloudBlock);
                });
                singleCloud.position.set(x, y, z);
                cloudGroup.add(singleCloud);
            }

            // Cloud definitions (array of blocks per cloud: {x,y,z offset from cloud center, size multiplier})
            const cloudShape1 = [ {x:0,y:0,z:0,size:2}, {x:1,y:0,z:0,size:2}, {x:-1,y:0,z:0,size:1.5}, {x:0,y:1,z:0,size:1.5} ];
            const cloudShape2 = [ {x:0,y:0,z:0,size:2.5}, {x:1.5,y:0,z:0,size:2}, {x:-1,y:0,z:0.5,size:2}, {x:0.5,y:0.5,z:0,size:1.5} ];
            const cloudShape3 = [ {x:0,y:0,z:0,size:2}, {x:1,y:0,z:0,size:1.5}, {x:2,y:0,z:0,size:2}, {x:0.5,y:0,z:1,size:1.5} ];

            const maxTowerHeightEstimate = (16 + 2) * CUBE_SIZE; // Estimate max Lotte tower height + buffer

            createCloud(cloudShape1, GRID_WIDTH * 0.2, maxTowerHeightEstimate + 20, -GRID_DEPTH * 1.5);
            createCloud(cloudShape2, GRID_WIDTH * 0.8, maxTowerHeightEstimate + 30, -GRID_DEPTH * 0.5);
            createCloud(cloudShape3, GRID_WIDTH * 0.5, maxTowerHeightEstimate + 25, GRID_DEPTH * 1.2);
            createCloud(cloudShape1, -GRID_WIDTH * 0.1, maxTowerHeightEstimate + 35, GRID_DEPTH * 0.8);
            
            scene.add(cloudGroup);


            // Camera setup
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 3000); // Adjusted FOV
            // Initial camera position will be refined after graph generation

            // --- Static Sunny Day Lighting ---
            // HemisphereLight
            hemisphereLight = new THREE.HemisphereLight(0xADD8E6, 0xBDB76B, 0.7); // Light blue sky, DarkKhaki ground
            scene.add(hemisphereLight);

            // Ambient light
            ambientLight = new THREE.AmbientLight(0xFFFFFF, 0.5);
            scene.add(ambientLight);

            // Directional light (Sun)
            directionalLight = new THREE.DirectionalLight(0xFFFFE0, 1.0); // Slightly yellow sun
            directionalLight.position.set(GRID_WIDTH * 0.3, 150, GRID_DEPTH * 0.2); // Higher and angled
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 4096;
            directionalLight.shadow.mapSize.height = 4096;
            directionalLight.shadow.camera.near = 10;
            directionalLight.shadow.camera.far = 300; // Increased far for larger scene with high sun
            directionalLight.shadow.camera.left = -GRID_WIDTH * 1.2; // Expanded frustum
            directionalLight.shadow.camera.right = GRID_WIDTH * 1.2;
            directionalLight.shadow.camera.top = GRID_DEPTH * 1.2;
            directionalLight.shadow.camera.bottom = -GRID_DEPTH * 1.2;
            directionalLight.shadow.bias = -0.0005;
            scene.add(directionalLight);
            // const shadowHelper = new THREE.CameraHelper(directionalLight.shadow.camera);
            // const shadowHelper = new THREE.CameraHelper(directionalLight.shadow.camera);
            // scene.add(shadowHelper);
            
            // Ground plane - REMOVED OLD PLANE
            // const planeGeometry = new THREE.PlaneGeometry(GRID_WIDTH * 2.5, GRID_DEPTH * 4); 
            // const planeMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22, roughness: 0.9, metalness: 0.1 }); 
            // const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            // plane.rotation.x = -Math.PI / 2;
            // plane.position.y = -CUBE_SIZE / 2 -0.01; 
            // plane.receiveShadow = true;
            // scene.add(plane);

            // --- Blocky Road Surface --- REMOVED



            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio); // For sharper images on high DPI displays
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer shadows
            renderer.toneMapping = THREE.ACESFilmicToneMapping; // Better color grading
            renderer.toneMappingExposure = 1.0;
            renderer.outputColorSpace = THREE.SRGBColorSpace; // Correct color space (for Three.js r128+, use outputEncoding for older)

            document.getElementById('container').appendChild(renderer.domElement);

            // OrbitControls setup
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.04; // Smoother damping
            controls.screenSpacePanning = false;
            controls.minDistance = 10;     // Prevent zooming too close
            controls.maxDistance = 200;    // Prevent zooming too far
            controls.minPolarAngle = Math.PI / 6; // Prevent looking from below ground (30 degrees)
            controls.maxPolarAngle = Math.PI / 2.2; // Prevent looking directly from top (approx 81 degrees)
            // Target will be set after graph generation

            // Raycasting setup
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Generate the 3D graph
            generateContributionGraph();

            // Event listeners
            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('mousemove', onMouseMove, false);
            
            // Start animation loop
            animate();
        }

        function generateContributionGraph() {
            if (typeof contributions === 'undefined' || contributions.length === 0) {
                console.error("Contributions data is not loaded or is empty.");
                return;
            }

            const sortedContributions = [...contributions].map(c => ({...c, dateObj: new Date(c.date)})).sort((a, b) => a.dateObj - b.dateObj);
            if (sortedContributions.length === 0) return;

            const firstDate = sortedContributions[0].dateObj;
            const startDateOfGrid = new Date(firstDate);
            startDateOfGrid.setDate(firstDate.getDate() - firstDate.getDay()); // Set to Sunday of the first week

            // Helper function createBlock was moved to global scope before init()

            sortedContributions.forEach(contrib => {
                const date = contrib.dateObj;
                const count = contrib.count;
                const dayOfWeek = date.getDay(); // 0 (Sunday) to 6 (Saturday)
                
                const timeDiff = date.getTime() - startDateOfGrid.getTime();
                const dayDiff = Math.floor(timeDiff / (1000 * 3600 * 24));
                const weekIndex = Math.floor(dayDiff / 7);

                if (weekIndex < 0 || weekIndex >= WEEKS_IN_YEAR) return;

                const x_position = weekIndex * (CUBE_SIZE + CUBE_SPACING);
                const z_position = dayOfWeek * (CUBE_SIZE + CUBE_SPACING);
                
                let modelGroup = new THREE.Group();
                modelGroup.position.set(x_position, 0, z_position); // Base of models at y=0

                let modelType = '';
                let primaryColor = null; // For userData, if needed for highlighting

                if (count === 0) {
                    modelType = 'bare_ground';
                    primaryColor = mc_colors.brown_dark;
                    // 3x3 grid of blocks (browns and dark green)
                    for (let i = -1; i <= 1; i++) {
                        for (let j = -1; j <= 1; j++) {
                            let blockColor = mc_colors.brown_light;
                            if (Math.random() < 0.3) blockColor = mc_colors.brown_dark;
                            else if (Math.random() < 0.2) blockColor = mc_colors.green_dark; // Fewer green blocks
                            modelGroup.add(createBlock(blockColor, i, 0, j));
                        }
                    }
                } else if (count >= 1 && count <= 2) {
                    modelType = 'starbucks';
                    primaryColor = mc_colors.starbucks_green;
                    // Approx 3x3 base, 3 blocks high.
                    // Layer Y=0 (Base - can be slightly darker white or light grey for differentiation)
                    for (let i = -1; i <= 1; i++) {
                        for (let j = -1; j <= 1; j++) {
                            modelGroup.add(createBlock(mc_colors.lotte_light_grey, i, 0, j));
                        }
                    }
                    // Layer Y=1 (Walls)
                    // Front: white, brown (door), white
                    modelGroup.add(createBlock(mc_colors.white, -1, 1, -1));
                    modelGroup.add(createBlock(mc_colors.starbucks_door_brown, 0, 1, -1)); 
                    modelGroup.add(createBlock(mc_colors.white, 1, 1, -1));
                    // Back: all white
                    modelGroup.add(createBlock(mc_colors.white, -1, 1, 1));
                    modelGroup.add(createBlock(mc_colors.white, 0, 1, 1));
                    modelGroup.add(createBlock(mc_colors.white, 1, 1, 1));
                    // Sides (with logo/window)
                    modelGroup.add(createBlock(mc_colors.white, -1, 1, 0)); // Left wall
                    modelGroup.add(createBlock(mc_colors.starbucks_green, 1, 1, 0)); // Right wall (logo placeholder)
                    
                    // Layer Y=2 (Upper Walls / Start of Roof elements)
                     // Front: white, white (above door), white
                    modelGroup.add(createBlock(mc_colors.white, -1, 2, -1));
                    modelGroup.add(createBlock(mc_colors.white, 0, 2, -1)); 
                    modelGroup.add(createBlock(mc_colors.white, 1, 2, -1));
                    // Back: all white
                    modelGroup.add(createBlock(mc_colors.white, -1, 2, 1));
                    modelGroup.add(createBlock(mc_colors.white, 0, 2, 1));
                    modelGroup.add(createBlock(mc_colors.white, 1, 2, 1));
                    // Sides
                    modelGroup.add(createBlock(mc_colors.window_blue, -1, 2, 0)); // Left wall (window)
                    modelGroup.add(createBlock(mc_colors.white, 1, 2, 0));    // Right wall
                    
                    // Layer Y=3 (Roof)
                    for (let i = -1; i <= 1; i++) {
                        for (let j = -1; j <= 1; j++) {
                            modelGroup.add(createBlock(mc_colors.starbucks_green, i, 3, j));
                        }
                    }
                } else if (count >= 3 && count <= 4) {
                    modelType = 'mcdonalds';
                    primaryColor = mc_colors.mcd_red;
                    // Approx 4x3 base, 3-4 blocks high.
                    // Base Layer Y=0 (slightly darker red or grey)
                    for (let i = -1.5; i <= 1.5; i++) { // 4 blocks wide ( -1.5, -0.5, 0.5, 1.5)
                        for (let j = -0.5; j <= 0.5; j++) { // 2 blocks deep ( -0.5, 0.5 ) to make it 4x2 base
                            modelGroup.add(createBlock(mc_colors.lotte_medium_grey, i, 0, j));
                        }
                    }
                    // Walls Layer Y=1, Y=2 (Red)
                    for (let y = 1; y <= 2; y++) {
                        // Front and Back walls (4 blocks wide)
                        for (let i = -1.5; i <= 1.5; i++) {
                            modelGroup.add(createBlock(mc_colors.mcd_red, i, y, -0.5)); // Front
                            modelGroup.add(createBlock(mc_colors.mcd_red, i, y, 0.5));  // Back
                        }
                        // Side walls (excluding corners already placed)
                        modelGroup.add(createBlock(mc_colors.mcd_red, -1.5, y, 0)); 
                        modelGroup.add(createBlock(mc_colors.mcd_red, 1.5, y, 0));
                    }
                    // Door (center front on Y=1)
                    modelGroup.add(createBlock(mc_colors.mcd_door_grey, -0.5, 1, -0.5)); // Assuming door is 1 block wide
                    modelGroup.add(createBlock(mc_colors.mcd_door_grey, 0.5, 1, -0.5));  // Wider door - 2 blocks
                    modelGroup.add(createBlock(mc_colors.mcd_red, -0.5, 2, -0.5)); // Red block above door
                    modelGroup.add(createBlock(mc_colors.mcd_red, 0.5, 2, -0.5));  // Red block above door

                    // Roof Layer Y=3 (Yellow)
                    for (let i = -1.5; i <= 1.5; i++) {
                        for (let j = -0.5; j <= 0.5; j++) {
                            modelGroup.add(createBlock(mc_colors.mcd_yellow, i, 3, j));
                        }
                    }
                    // "M" Hint (Yellow on front roof edge, simple version)
                    modelGroup.add(createBlock(mc_colors.mcd_yellow, -0.5, 2, -1.5)); // Lower part of M on front wall
                    modelGroup.add(createBlock(mc_colors.mcd_yellow, 0.5, 2, -1.5));  // Lower part of M
                    modelGroup.add(createBlock(mc_colors.mcd_yellow, 0, 3, -1.5));    // Top part of M on roof
                
                } else { // count >= 5
                    modelType = 'lotte_tower';
                    primaryColor = mc_colors.lotte_light_grey;
                    const towerHeight = 12 + Math.min(Math.floor((count - 5) / 2), 4); // Base 12, +1 for every 2 extra counts, max 16

                    // Base section (4x4 footprint, e.g., Y=0 to Y=2)
                    for (let y = 0; y < 3; y++) {
                        for (let i = -1.5; i <= 1.5; i++) {
                            for (let j = -1.5; j <= 1.5; j++) {
                                let color = ( (i+j) % 2 === 0) ? mc_colors.lotte_light_grey : mc_colors.lotte_medium_grey;
                                modelGroup.add(createBlock(color, i, y, j));
                            }
                        }
                    }
                    // Mid-section 1 (3x3 footprint, e.g., Y=3 to Y=5)
                    for (let y = 3; y < 6; y++) {
                        for (let i = -0.5; i <= 0.5; i++) { // Centered 3 blocks
                            for (let j = -0.5; j <= 0.5; j++) {
                                let color = mc_colors.lotte_light_grey;
                                if (Math.random() < 0.3) color = mc_colors.lotte_dark_blue_window;
                                modelGroup.add(createBlock(color, i, y, j));
                            }
                        }
                    }
                    // Mid-section 2 (2x2 footprint, e.g., Y=6 to Y=8)
                     for (let y = 6; y < 9; y++) {
                        for (let i = -0.5; i <= 0.5; i+=1) { // Centered 2 blocks
                             for (let j = -0.5; j <= 0.5; j+=1) {
                                let color = mc_colors.lotte_white;
                                if (Math.random() < 0.4) color = mc_colors.lotte_dark_blue_window;
                                modelGroup.add(createBlock(color, i, y, j));
                            }
                        }
                    }
                     // Top section (2x2 narrowing to 1x1 or similar, Y=9 to towerHeight-1)
                    for (let y = 9; y < towerHeight -1 ; y++) {
                        let size = (y < towerHeight - 3) ? 0.5 : 0; // Make top part narrower (effectively 1x1 for last few layers)
                        for (let i = -size; i <= size; i+=1) {
                             for (let j = -size; j <= size; j+=1) {
                                modelGroup.add(createBlock(mc_colors.lotte_white, i, y, j));
                            }
                        }
                    }
                    // Spire (Y=towerHeight-1)
                    modelGroup.add(createBlock(mc_colors.lotte_light_grey, 0, towerHeight-1, 0));
                }

                modelGroup.userData = {
                    date: date.toISOString().split('T')[0],
                    count: count,
                    type: modelType,
                    isContributionObject: true, 
                    originalColor: primaryColor ? primaryColor.clone() : null, // Store a base color for potential highlight
                    // bloomMesh might refer to the modelGroup itself or a specific part if complex highlighting is needed
                    highlightableMeshes: modelGroup.children.slice() // Store all children for group highlight
                };
                contributionCubesGroup.add(modelGroup);
            });
            
            // --- Final Camera and Controls Target Adjustment ---
            const gridWidth = WEEKS_IN_YEAR * (CUBE_SIZE + CUBE_SPACING);
            const gridDepth = DAYS_IN_WEEK * (CUBE_SIZE + CUBE_SPACING);
            
            // Center of the grid on XZ plane
            const centerX = (WEEKS_IN_YEAR -1) * (CUBE_SIZE + CUBE_SPACING) / 2;
            const centerZ = (DAYS_IN_WEEK -1) * (CUBE_SIZE + CUBE_SPACING) / 2;

            camera.position.set(centerX, Math.max(gridWidth, gridDepth) * 0.6, centerZ + gridDepth * 2.5); // Position relative to center
            controls.target.set(centerX, 0, centerZ); // Look at the center of the grid
            controls.update();
        }

        // --- Event Handlers ---
        function onMouseMove(event) {
            event.preventDefault();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(contributionCubesGroup.children, true); // Recursive to get stem/bloom

            if (intersects.length > 0) {
                let intersectedObject = intersects[0].object;
                let contributionGroup = null;

                // Traverse up to find the main flower group (if a part of it was intersected)
                while (intersectedObject) {
                    if (intersectedObject.userData && intersectedObject.userData.isContributionObject) {
                        contributionGroup = intersectedObject;
                        break;
                    }
                    if (!intersectedObject.parent) break; // Stop if no parent
                    intersectedObject = intersectedObject.parent;
                }

                if (contributionGroup) {
                    if (intersectedCube !== contributionGroup) {
                        if (intersectedCube && intersectedCube.userData.highlightableMeshes) {
                            // Reset previous group's emissive
                            intersectedCube.userData.highlightableMeshes.forEach(mesh => {
                                if (mesh.material) mesh.material.emissive.setHex(0x000000);
                            });
                        }
                        intersectedCube = contributionGroup;
                        if (intersectedCube.userData.highlightableMeshes) {
                            // Set emissive for current group
                            intersectedCube.userData.highlightableMeshes.forEach(mesh => {
                                if (mesh.material) mesh.material.emissive.setHex(0x555555); // Moderate grey emissive
                            });
                        }
                        tooltipElement.style.display = 'block';
                        tooltipElement.innerHTML = `Date: ${intersectedCube.userData.date}<br>Contributions: ${intersectedCube.userData.count}<br>Type: ${intersectedCube.userData.type}`;
                    }
                    tooltipElement.style.left = (event.clientX + 10) + 'px';
                    tooltipElement.style.top = (event.clientY - 25) + 'px';
                } else {
                    hideTooltipAndResetObject();
                }
            } else {
                hideTooltipAndResetObject();
            }
        }
        
        function hideTooltipAndResetObject() { 
            if (intersectedCube && intersectedCube.userData.highlightableMeshes) {
                intersectedCube.userData.highlightableMeshes.forEach(mesh => {
                     if (mesh.material) mesh.material.emissive.setHex(0x000000);
                });
                intersectedCube = null;
            }
            tooltipElement.style.display = 'none';
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            // Update sky - REMOVED DYNAMIC LOGIC

            controls.update(); // Only if enableDamping or autoRotate is true
            renderer.render(scene, camera);
        }

        // --- Start ---
        init();
    </script>
</body>
</html>
