<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitHub Contributions 3D Interactive - Enhanced</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; /* Slightly lighter dark */ }
        #container { width: 100vw; height: 100vh; display: block; }
        #tooltip {
            position: absolute;
            display: none;
            background-color: rgba(245, 245, 245, 0.95); /* Slightly off-white */
            border: 1px solid #aaa;
            padding: 10px;
            border-radius: 5px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; /* Modern font */
            font-size: 13px;
            color: #222;
            pointer-events: none;
            z-index: 100;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1); /* Subtle shadow */
        }
    </style>
</head>
<body>
    <div id="tooltip"></div>
    <div id="container"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="garden.js"></script> <!-- Load contributions data -->
    <script>
        // --- Constants ---
        const CUBE_SIZE = 1.0;
        const CUBE_SPACING = 0.3;
        const DAYS_IN_WEEK = 7;
        const WEEKS_IN_YEAR = 53; // Standard GitHub contribution graph width

        const HIGHLIGHT_COLOR = 0xffdc73; // Softer yellow for highlighting
        // const SCENE_BACKGROUND_COLOR = 0x282c34; // Darker, slightly bluish background - REMOVED for dynamic sky
        // const FOG_COLOR = SCENE_BACKGROUND_COLOR; - REMOVED for dynamic sky
        const FOG_NEAR_FACTOR = 2.5; // Fog starts further out based on grid size
        const FOG_FAR_FACTOR = 4.5;  // Fog ends further out

        // --- Pre-calculate Grid Dimensions (used in lighting setup) ---
        const GRID_WIDTH = WEEKS_IN_YEAR * (CUBE_SIZE + CUBE_SPACING);
        const GRID_DEPTH = DAYS_IN_WEEK * (CUBE_SIZE + CUBE_SPACING);

        // --- Sky Cycle Variables with Lighting ---
        const dawnColors = {
            background: new THREE.Color(0xffa07a), // Light Salmon
            fog: new THREE.Color(0xffd8b1),         // Wheat
            lighting: { // Tuned for Tulips
                hemisphereLight: { skyColor: new THREE.Color(0xffa07a), groundColor: new THREE.Color(0x504030), intensity: 0.8 }, 
                ambientLight: { color: new THREE.Color(0xffa07a), intensity: 0.45 }, // Boosted ambient for overall visibility
                directionalLight: { color: new THREE.Color(0xffebd0), intensity: 0.7, position: new THREE.Vector3(-GRID_WIDTH * 0.3, 60, GRID_DEPTH * 0.7) } // Less saturated warm light
            }
        };
        const dayColors = {
            background: new THREE.Color(0x87ceeb), // Sky Blue
            fog: new THREE.Color(0xb0e0e6),         // Powder Blue
            lighting: { // Tuned for Tulips
                hemisphereLight: { skyColor: new THREE.Color(0x87ceeb), groundColor: new THREE.Color(0x888888), intensity: 0.9 }, // Slightly brighter ground
                ambientLight: { color: new THREE.Color(0xfffff0), intensity: 0.4 }, // Pale yellow ambient, slightly reduced
                directionalLight: { color: new THREE.Color(0xfff5e1), intensity: 0.8, position: new THREE.Vector3(GRID_WIDTH * 0.1, 80, GRID_DEPTH * 0.5) } // Softer, slightly warmer white directional
            }
        };
        const duskColors = {
            background: new THREE.Color(0xff7f50), // Coral
            fog: new THREE.Color(0xffb347),         // Dark Salmon (using a more orangey fog)
            lighting: { // Tuned for Tulips
                hemisphereLight: { skyColor: new THREE.Color(0xff7f50), groundColor: new THREE.Color(0x504030), intensity: 0.75 },
                ambientLight: { color: new THREE.Color(0xff7f50), intensity: 0.4 }, // Boosted ambient
                directionalLight: { color: new THREE.Color(0xffc8a0), intensity: 0.8, position: new THREE.Vector3(GRID_WIDTH * 0.5, 60, GRID_DEPTH * 0.7) } // Golden hour, less saturated orange
            }
        };
        const nightColors = {
            background: new THREE.Color(0x000033), // Dark Navy
            fog: new THREE.Color(0x000020),         // Very Dark Blue
            lighting: { // Tuned for Tulips
                hemisphereLight: { skyColor: new THREE.Color(0x252545), groundColor: new THREE.Color(0x101018), intensity: 0.4 }, // Slightly more intensity, subtle warmth in ground
                ambientLight: { color: new THREE.Color(0x454555), intensity: 0.25 }, // More neutral cool ambient, slightly increased
                directionalLight: { color: new THREE.Color(0x8080aa), intensity: 0.4, position: new THREE.Vector3(GRID_WIDTH * 0.2, 70, GRID_DEPTH * 1.0) } // Whiter moonlight, slightly more intensity
            }
        };
        const skyCycle = [dawnColors, dayColors, duskColors, nightColors];
        let currentSkyColorIndex = 0;
        let nextSkyColorIndex = 1;
        let skyTransitionProgress = 0;
        const skyTransitionSpeed = 0.0005; // Adjust for speed of transition
        // const skyPhaseDuration = 1; // This will be normalized by skyTransitionProgress >= 1.0

        // --- Tulip Colors ---
        const tulipColors = [new THREE.Color(0xff0000), /* Red */ new THREE.Color(0xffff00), /* Yellow */ new THREE.Color(0xffc0cb) /* Pink */];

        // --- Global Three.js Variables ---
        let scene, camera, renderer, controls;
        let hemisphereLight, ambientLight, directionalLight; // Made global for updating in animate()
        let raycaster, mouse;
        let contributionCubesGroup;
        let intersectedCube = null;
        let tooltipElement;

        // --- Helper Functions ---
        function mapCountToColor(count) {
            if (count === 0) return 0x383838; // Darker grey for no contributions
            if (count >= 1 && count <= 2) return 0x0e4429;
            if (count >= 3 && count <= 5) return 0x006d32;
            if (count >= 6 && count <= 9) return 0x26a641;
            return 0x39d353; // GitHub's brightest green
        }
        
        function mapCountToHeight(count) {
            if (count === 0) return 0.1; // Minimal height for zero contributions
            // Logarithmic scale, slightly adjusted for more visual impact
            const height = 0.3 + Math.log1p(count) * 1.2; 
            return Math.min(height, 20); // Increased max height cap
        }

        // --- Initialization ---
        function init() {
            tooltipElement = document.getElementById('tooltip');
            
            // Scene setup
            scene = new THREE.Scene();
            // scene.background = new THREE.Color(SCENE_BACKGROUND_COLOR); // REMOVED for dynamic sky
            scene.background = new THREE.Color().copy(skyCycle[0].background); // Initial background

            const gridWidth = WEEKS_IN_YEAR * (CUBE_SIZE + CUBE_SPACING);
            const gridDepth = DAYS_IN_WEEK * (CUBE_SIZE + CUBE_SPACING);
            // scene.fog = new THREE.Fog(FOG_COLOR, Math.max(gridWidth, gridDepth) * FOG_NEAR_FACTOR, Math.max(gridWidth, gridDepth) * FOG_FAR_FACTOR);
            // Initial fog, color will be updated dynamically
            scene.fog = new THREE.Fog(skyCycle[0].fog.getHex(), Math.max(gridWidth, gridDepth) * FOG_NEAR_FACTOR, Math.max(gridWidth, gridDepth) * FOG_FAR_FACTOR);
            scene.fog.color.copy(skyCycle[0].fog);


            contributionCubesGroup = new THREE.Group();
            scene.add(contributionCubesGroup);

            // Camera setup
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 3000); // Adjusted FOV
            // Initial camera position will be refined after graph generation

            // Lighting setup - Initialized with the first sky phase
            const initialLighting = skyCycle[0].lighting;

            // HemisphereLight (now global)
            hemisphereLight = new THREE.HemisphereLight(
                initialLighting.hemisphereLight.skyColor,
                initialLighting.hemisphereLight.groundColor,
                initialLighting.hemisphereLight.intensity
            );
            scene.add(hemisphereLight);

            // Ambient light (now global)
            ambientLight = new THREE.AmbientLight(
                initialLighting.ambientLight.color,
                initialLighting.ambientLight.intensity
            );
            scene.add(ambientLight);

            // Directional light (now global)
            directionalLight = new THREE.DirectionalLight(
                initialLighting.directionalLight.color,
                initialLighting.directionalLight.intensity
            );
            directionalLight.position.copy(initialLighting.directionalLight.position);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 4096;
            directionalLight.shadow.mapSize.height = 4096;
            directionalLight.shadow.camera.near = 10;
            directionalLight.shadow.camera.far = 200; 
            // Shadow camera frustum uses GRID_WIDTH and GRID_DEPTH (now global)
            directionalLight.shadow.camera.left = -GRID_WIDTH / 1.8;
            directionalLight.shadow.camera.right = GRID_WIDTH / 1.8;
            directionalLight.shadow.camera.top = GRID_DEPTH / 1.5;
            directionalLight.shadow.camera.bottom = -GRID_DEPTH / 1.5;
            directionalLight.shadow.bias = -0.0005;
            scene.add(directionalLight);
            // const shadowHelper = new THREE.CameraHelper(directionalLight.shadow.camera);
            // scene.add(shadowHelper);
            
            // Ground plane
            const planeGeometry = new THREE.PlaneGeometry(GRID_WIDTH * 1.5, GRID_DEPTH * 3); // Larger plane
            const planeMaterial = new THREE.MeshStandardMaterial({ color: 0x202020, roughness: 0.9, metalness: 0.1 });
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = -Math.PI / 2;
            plane.position.y = -0.2; // Ensure it's below cubes, even those with 0.1 height
            plane.receiveShadow = true;
            scene.add(plane);

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio); // For sharper images on high DPI displays
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer shadows
            renderer.toneMapping = THREE.ACESFilmicToneMapping; // Better color grading
            renderer.toneMappingExposure = 1.0;
            renderer.outputColorSpace = THREE.SRGBColorSpace; // Correct color space (for Three.js r128+, use outputEncoding for older)

            document.getElementById('container').appendChild(renderer.domElement);

            // OrbitControls setup
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.04; // Smoother damping
            controls.screenSpacePanning = false;
            controls.minDistance = 10;     // Prevent zooming too close
            controls.maxDistance = 200;    // Prevent zooming too far
            controls.minPolarAngle = Math.PI / 6; // Prevent looking from below ground (30 degrees)
            controls.maxPolarAngle = Math.PI / 2.2; // Prevent looking directly from top (approx 81 degrees)
            // Target will be set after graph generation

            // Raycasting setup
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Generate the 3D graph
            generateContributionGraph();

            // Event listeners
            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('mousemove', onMouseMove, false);
            
            // Start animation loop
            animate();
        }

        function generateContributionGraph() {
            if (typeof contributions === 'undefined' || contributions.length === 0) {
                console.error("Contributions data is not loaded or is empty.");
                return;
            }

            const sortedContributions = [...contributions].map(c => ({...c, dateObj: new Date(c.date)})).sort((a, b) => a.dateObj - b.dateObj);
            if (sortedContributions.length === 0) return;

            const firstDate = sortedContributions[0].dateObj;
            const startDateOfGrid = new Date(firstDate);
            startDateOfGrid.setDate(firstDate.getDate() - firstDate.getDay()); // Set to Sunday of the first week

            sortedContributions.forEach(contrib => {
                const date = contrib.dateObj;
                const count = contrib.count;
                const dayOfWeek = date.getDay(); // 0 (Sunday) to 6 (Saturday)
                
                const timeDiff = date.getTime() - startDateOfGrid.getTime();
                const dayDiff = Math.floor(timeDiff / (1000 * 3600 * 24));
                const weekIndex = Math.floor(dayDiff / 7);

                if (weekIndex < 0 || weekIndex >= WEEKS_IN_YEAR) return; // Skip dates outside the 53-week window

                const x_position = weekIndex * (CUBE_SIZE + CUBE_SPACING);
                const z_position = dayOfWeek * (CUBE_SIZE + CUBE_SPACING);
                
                let objectGroup = new THREE.Group();
                objectGroup.position.set(x_position, 0, z_position);

                if (count === 0) {
                    // Bare Ground
                    const groundRadius = CUBE_SIZE * 0.3;
                    const groundGeometry = new THREE.CylinderGeometry(groundRadius, groundRadius, 0.05, 16);
                    const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x654321, roughness: 0.9, metalness: 0.0 });
                    const groundDisc = new THREE.Mesh(groundGeometry, groundMaterial);
                    groundDisc.position.y = -0.15 + 0.025; // Slightly above plane, accounting for its own height
                    groundDisc.castShadow = false;
                    groundDisc.receiveShadow = true;
                    objectGroup.add(groundDisc);
                    objectGroup.userData = {
                        date: date.toISOString().split('T')[0],
                        count: count,
                        isContributionObject: true,
                        isBareGround: true,
                        originalColor: new THREE.Color(0x654321), // Store its own color
                        bloomMesh: groundDisc // Can be itself for potential minor highlight
                    };
                } else if (count === 1) {
                    // Sprout
                    const sproutMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00, roughness: 0.7, metalness: 0.1 });
                    const leafGeometry = new THREE.SphereGeometry(CUBE_SIZE * 0.15, 6, 4);
                    leafGeometry.scale(1, 1.8, 0.5); // Elongate and flatten

                    const leaf1 = new THREE.Mesh(leafGeometry, sproutMaterial);
                    leaf1.position.set(0, CUBE_SIZE * 0.1, 0);
                    leaf1.rotation.z = Math.PI / 6;
                    leaf1.rotation.y = Math.PI / 4;
                    leaf1.castShadow = true;
                    leaf1.receiveShadow = true;
                    objectGroup.add(leaf1);

                    const leaf2 = new THREE.Mesh(leafGeometry, sproutMaterial);
                    leaf2.position.set(0, CUBE_SIZE * 0.12, 0); // Slightly different height
                    leaf2.rotation.z = -Math.PI / 6;
                    leaf2.rotation.y = -Math.PI / 4;
                    leaf2.castShadow = true;
                    leaf2.receiveShadow = true;
                    objectGroup.add(leaf2);
                    
                    objectGroup.userData = {
                        date: date.toISOString().split('T')[0],
                        count: count,
                        isContributionObject: true,
                        isSprout: true,
                        originalColor: new THREE.Color(0x00ff00),
                        bloomMesh: leaf1 // Highlight one of the leaves
                    };
                } else { // count > 1 (Tulip)
                    const stemHeight = mapCountToHeight(count); // Ensure this is appropriate for tulips
                    const stemRadius = CUBE_SIZE * 0.05;

                    // Stem
                    const stemMaterial = new THREE.MeshStandardMaterial({ color: 0x008000, roughness: 0.7, metalness: 0.1 });
                    const stemGeometry = new THREE.CylinderGeometry(stemRadius, stemRadius, stemHeight, 8);
                    const stem = new THREE.Mesh(stemGeometry, stemMaterial);
                    stem.position.y = stemHeight / 2;
                    stem.castShadow = true;
                    stem.receiveShadow = true;
                    objectGroup.add(stem);

                    // Tulip Leaves
                    const tulipLeafMaterial = new THREE.MeshStandardMaterial({ color: 0x007000, roughness: 0.6, metalness: 0.1 });
                    const leafShape = new THREE.Shape();
                    leafShape.moveTo(0, 0);
                    leafShape.bezierCurveTo(0.1, 0.3, 0.15, 0.7, 0.05, stemHeight * 0.4); // Broader base, tapers
                    leafShape.bezierCurveTo(-0.05, 0.7, -0.1, 0.3, 0, 0);
                    const leafGeometry = new THREE.ShapeGeometry(leafShape);
                    
                    const numTulipLeaves = count < 5 ? 1 : 2;
                    for (let i = 0; i < numTulipLeaves; i++) {
                        const tulipLeaf = new THREE.Mesh(leafGeometry, tulipLeafMaterial);
                        tulipLeaf.position.set(stemRadius * (i === 0 ? 1.5 : -1.5), stemHeight * 0.1, 0);
                        tulipLeaf.rotation.x = Math.PI / 12 * (i === 0 ? 1 : -1);
                        tulipLeaf.rotation.y = Math.PI / 2 + (i === 0 ? Math.PI / 6 : -Math.PI / 6);
                        tulipLeaf.rotation.z = Math.PI / 8 * (i === 0 ? -1 : 1);
                        tulipLeaf.castShadow = true;
                        tulipLeaf.receiveShadow = true;
                        objectGroup.add(tulipLeaf);
                    }

                    // Tulip Bloom
                    const bloomHeadGroup = new THREE.Group();
                    const headScale = 0.2 + Math.log1p(count -1) * 0.1; // Scale bloom with count (starting from count=2)
                    bloomHeadGroup.scale.set(headScale, headScale, headScale);
                    bloomHeadGroup.position.y = stemHeight;
                    objectGroup.add(bloomHeadGroup);

                    const petalColor = tulipColors[Math.floor(Math.random() * tulipColors.length)];
                    const petalMaterial = new THREE.MeshStandardMaterial({ 
                        color: petalColor, 
                        roughness: 0.5, 
                        metalness: 0.2,
                        side: THREE.DoubleSide // Ensure inside of petals are visible
                    });
                    
                    // Simple petal geometry (elongated sphere part)
                    const petalShapeGeometry = new THREE.SphereGeometry(CUBE_SIZE * 0.5, 12, 8, 0, Math.PI * 2, 0, Math.PI / 2.5);
                    petalShapeGeometry.scale(0.6, 1, 0.3); // Elongate and flatten
                    
                    const numPetals = 5; // Fixed number of petals for a simpler tulip look
                    for (let i = 0; i < numPetals; i++) {
                        const petal = new THREE.Mesh(petalShapeGeometry, petalMaterial);
                        const angle = (i / numPetals) * Math.PI * 2;
                        petal.position.set(
                            Math.cos(angle) * CUBE_SIZE * 0.15, 
                            CUBE_SIZE * 0.3, // Lift petals to form cup base
                            Math.sin(angle) * CUBE_SIZE * 0.15
                        );
                        petal.rotation.y = -angle + Math.PI / 2; // Orient petal outwards
                        petal.rotation.x = Math.PI / 4; // Angle upwards
                        petal.castShadow = true;
                        petal.receiveShadow = true;
                        bloomHeadGroup.add(petal);
                    }
                    
                    objectGroup.userData = {
                        date: date.toISOString().split('T')[0],
                        count: count,
                        isContributionObject: true,
                        isTulip: true,
                        originalColor: petalColor.clone(),
                        bloomMesh: bloomHeadGroup // Highlight the whole bloom head
                    };
                }
                contributionCubesGroup.add(objectGroup);
            });
            
            // --- Final Camera and Controls Target Adjustment ---
            const gridWidth = WEEKS_IN_YEAR * (CUBE_SIZE + CUBE_SPACING);
            const gridDepth = DAYS_IN_WEEK * (CUBE_SIZE + CUBE_SPACING);
            
            // Center of the grid on XZ plane
            const centerX = (WEEKS_IN_YEAR -1) * (CUBE_SIZE + CUBE_SPACING) / 2;
            const centerZ = (DAYS_IN_WEEK -1) * (CUBE_SIZE + CUBE_SPACING) / 2;

            camera.position.set(centerX, Math.max(gridWidth, gridDepth) * 0.6, centerZ + gridDepth * 2.5); // Position relative to center
            controls.target.set(centerX, 0, centerZ); // Look at the center of the grid
            controls.update();
        }

        // --- Event Handlers ---
        function onMouseMove(event) {
            event.preventDefault();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(contributionCubesGroup.children, true); // Recursive to get stem/bloom

            if (intersects.length > 0) {
                let intersectedObject = intersects[0].object;
                let contributionGroup = null;

                // Traverse up to find the main flower group (if a part of it was intersected)
                while (intersectedObject) {
                    if (intersectedObject.userData && intersectedObject.userData.isContributionObject) {
                        contributionGroup = intersectedObject;
                        break;
                    }
                    if (!intersectedObject.parent) break; // Stop if no parent
                    intersectedObject = intersectedObject.parent;
                }

                if (contributionGroup) {
                    if (intersectedCube !== contributionGroup) { 
                        if (intersectedCube && intersectedCube.userData.bloomMesh) {
                            if (intersectedCube.userData.isTulip) {
                                // Reset color for all petals in the bloomMesh group
                                intersectedCube.userData.bloomMesh.children.forEach(child => {
                                    if(child.material) child.material.color.set(intersectedCube.userData.originalColor);
                                });
                            } else if (intersectedCube.userData.bloomMesh.material) { // For single mesh objects like sprout leaf or ground
                                intersectedCube.userData.bloomMesh.material.color.set(intersectedCube.userData.originalColor);
                            }
                        }
                        intersectedCube = contributionGroup;
                        if (intersectedCube.userData.bloomMesh) {
                            if (intersectedCube.userData.isTulip) {
                                intersectedCube.userData.bloomMesh.children.forEach(child => {
                                     if(child.material) child.material.color.set(HIGHLIGHT_COLOR);
                                });
                            } else if (intersectedCube.userData.bloomMesh.material) { // For single mesh objects
                                if (!intersectedCube.userData.isBareGround) { // Don't highlight bare ground with yellow
                                   intersectedCube.userData.bloomMesh.material.color.set(HIGHLIGHT_COLOR);
                                } else {
                                    // Optionally, slightly lighten bare ground
                                    const groundHighlightColor = new THREE.Color(0x7a5f3e); // Slightly lighter brown
                                    intersectedCube.userData.bloomMesh.material.color.set(groundHighlightColor);
                                }
                            }
                        }
                        tooltipElement.style.display = 'block';
                        tooltipElement.innerHTML = `Date: ${intersectedCube.userData.date}<br>Contributions: ${intersectedCube.userData.count}`;
                    }
                    tooltipElement.style.left = (event.clientX + 10) + 'px';
                    tooltipElement.style.top = (event.clientY - 25) + 'px';
                } else {
                    hideTooltipAndResetObject();
                }
            } else {
                hideTooltipAndResetObject();
            }
        }
        
        function hideTooltipAndResetObject() { // Renamed from hideTooltipAndResetFlower
            if (intersectedCube && intersectedCube.userData.bloomMesh) {
                if (intersectedCube.userData.isTulip) {
                    intersectedCube.userData.bloomMesh.children.forEach(child => {
                        if(child.material) child.material.color.set(intersectedCube.userData.originalColor);
                    });
                } else if (intersectedCube.userData.bloomMesh.material) { // For single mesh objects
                     intersectedCube.userData.bloomMesh.material.color.set(intersectedCube.userData.originalColor);
                }
                intersectedCube = null;
            }
            tooltipElement.style.display = 'none';
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            // Update sky
            skyTransitionProgress += skyTransitionSpeed;
            if (skyTransitionProgress >= 1.0) {
                skyTransitionProgress = 0;
                currentSkyColorIndex = (currentSkyColorIndex + 1) % skyCycle.length;
                nextSkyColorIndex = (nextSkyColorIndex + 1) % skyCycle.length;
            }
            const currentColorSet = skyCycle[currentSkyColorIndex];
            const nextColorSet = skyCycle[nextSkyColorIndex];
            
            if (scene.background.isColor) { // Ensure scene.background is a THREE.Color object
                scene.background.lerpColors(currentColorSet.background, nextColorSet.background, skyTransitionProgress);
            } else { // Fallback if it's not (e.g. null or texture) - though we set it to a color in init
                scene.background = new THREE.Color().lerpColors(currentColorSet.background, nextColorSet.background, skyTransitionProgress);
            }
            
            if (scene.fog && scene.fog.color.isColor) {
                scene.fog.color.lerpColors(currentColorSet.fog, nextColorSet.fog, skyTransitionProgress);
            }

            // Update lighting
            const currentLighting = currentColorSet.lighting;
            const nextLighting = nextColorSet.lighting;

            // HemisphereLight
            if (hemisphereLight) {
                hemisphereLight.color.lerpColors(currentLighting.hemisphereLight.skyColor, nextLighting.hemisphereLight.skyColor, skyTransitionProgress);
                hemisphereLight.groundColor.lerpColors(currentLighting.hemisphereLight.groundColor, nextLighting.hemisphereLight.groundColor, skyTransitionProgress);
                hemisphereLight.intensity = THREE.MathUtils.lerp(currentLighting.hemisphereLight.intensity, nextLighting.hemisphereLight.intensity, skyTransitionProgress);
            }

            // AmbientLight
            if (ambientLight) {
                ambientLight.color.lerpColors(currentLighting.ambientLight.color, nextLighting.ambientLight.color, skyTransitionProgress);
                ambientLight.intensity = THREE.MathUtils.lerp(currentLighting.ambientLight.intensity, nextLighting.ambientLight.intensity, skyTransitionProgress);
            }

            // DirectionalLight
            if (directionalLight) {
                directionalLight.color.lerpColors(currentLighting.directionalLight.color, nextLighting.directionalLight.color, skyTransitionProgress);
                directionalLight.intensity = THREE.MathUtils.lerp(currentLighting.directionalLight.intensity, nextLighting.directionalLight.intensity, skyTransitionProgress);
                directionalLight.position.lerpVectors(currentLighting.directionalLight.position, nextLighting.directionalLight.position, skyTransitionProgress);
                // If directionalLight.target changes, or if you want it to always point to scene center:
                // directionalLight.target.position.set(controls.target.x, controls.target.y, controls.target.z); // Assuming controls.target is the scene center
                // scene.add(directionalLight.target); // if target is a new object
            }

            controls.update(); // Only if enableDamping or autoRotate is true
            renderer.render(scene, camera);
        }

        // --- Start ---
        init();
    </script>
</body>
</html>
